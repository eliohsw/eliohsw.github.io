<div class="toc-container" id="toc-container">
  <div class="toc-header">
    <h4>Contents</h4>
    <a href="#" class="toc-top-btn" id="toc-top-btn" title="Back to top">TOP</a>
    <button class="toc-toggle" id="toc-toggle" aria-label="Toggle table of contents">
      <ion-icon name="chevron-down-outline"></ion-icon>
    </button>
  </div>
  <div class="toc-content" id="toc-content">
    <div class="toc-content-header">
      <span>Contents</span>
      <a href="#" class="toc-top-btn toc-top-btn--dropdown" title="Back to top">TOP</a>
    </div>
    <nav class="toc-nav">
      <!-- TOC will be populated by JavaScript -->
    </nav>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const tocContainer = document.getElementById('toc-container');
  const tocHeader = document.querySelector('.toc-header');
  const tocContent = document.getElementById('toc-content');
  const tocToggle = document.getElementById('toc-toggle');
  const tocNav = document.querySelector('.toc-nav');
  const tocAnchor = document.querySelector('.breadcrumb');
  const fullWidthQuery = '(min-width: calc(800px + 280px + 3 * 2rem + 0.02px))';
  const mobileQuery = '(max-width: 575px)';
  const fullWidthMedia = window.matchMedia(fullWidthQuery);
  const mobileMedia = window.matchMedia(mobileQuery);
  let tocHeadings = [];
  let tocLinks = [];
  let scrollSpyInitialized = false;
  let tocMinTop = null;

  function updateTocMinTop() {
    if (fullWidthMedia.matches || mobileMedia.matches) {
      tocContainer.style.removeProperty('--toc-float-top');
      tocMinTop = null;
      return;
    }
    tocContainer.style.removeProperty('--toc-float-top');
    tocMinTop = parseFloat(getComputedStyle(tocContainer).top) || 0;
  }

  function updateTocFloatingTop() {
    if (!tocAnchor) return;
    if (fullWidthMedia.matches || mobileMedia.matches) {
      tocContainer.style.removeProperty('--toc-float-top');
      tocMinTop = null;
      return;
    }
    if (tocMinTop === null) updateTocMinTop();
    const anchorTop = tocAnchor.getBoundingClientRect().top;
    const clampedTop = Math.max(tocMinTop, anchorTop);
    tocContainer.style.setProperty('--toc-float-top', `${clampedTop}px`);
  }

  function updateActiveLink() {
    if (tocHeadings.length === 0 || tocLinks.length === 0) return;
    let currentHeading = null;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    if (scrollTop > 50) {
      tocHeadings.forEach(heading => {
        if (heading.getBoundingClientRect().top + scrollTop <= scrollTop + 100) {
          currentHeading = heading;
        }
      });
    }
    
    tocLinks.forEach(link => {
      link.classList.remove('active');
      if (currentHeading && link.getAttribute('href') === '#' + currentHeading.id) {
        link.classList.add('active');
      }
    });
  }

  function initScrollSpy() {
    if (scrollSpyInitialized) return;
    let ticking = false;
    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          updateActiveLink();
          updateTocFloatingTop();
          ticking = false;
        });
        ticking = true;
      }
    });
    scrollSpyInitialized = true;
  }
  
  function generateTOC() {
    const contentContainer = document.querySelector('.blog-post-content, .project-content');
    if (!contentContainer) {
      tocContainer.style.display = 'none';
      return;
    }
    
    const headings = contentContainer.querySelectorAll('h1, h2, h3');
    if (headings.length === 0) {
      tocContainer.style.display = 'none';
      return;
    }
    tocHeadings = Array.from(headings);
    
    function getTextWidth(text, font) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = font;
      return context.measureText(text).width;
    }
    
    function getTocMetrics() {
      const el = document.createElement('a');
      el.className = 'toc-link';
      el.style.cssText = 'visibility:hidden;position:absolute';
      el.textContent = 'Sample';
      document.body.appendChild(el);
      const style = getComputedStyle(el);
      const font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
      const paddingX = (parseFloat(style.paddingLeft) || 0) + (parseFloat(style.paddingRight) || 0);
      document.body.removeChild(el);
      return { font, paddingX };
    }

    function getNestedIndent() {
      const el = document.createElement('ul');
      el.className = 'toc-list toc-nested';
      el.style.cssText = 'visibility:hidden;position:absolute';
      tocNav.appendChild(el);
      const indent = parseFloat(getComputedStyle(el).paddingLeft) || 0;
      tocNav.removeChild(el);
      return indent;
    }

    function getMaxWidths() {
      const metrics = getTocMetrics();
      const contentStyles = getComputedStyle(tocContent);
      const contentPaddingX = (parseFloat(contentStyles.paddingLeft) || 0) + (parseFloat(contentStyles.paddingRight) || 0);
      const contentWidth = tocContent.getBoundingClientRect().width || tocContainer.getBoundingClientRect().width;
      const nestedIndent = getNestedIndent();
      const fallbackBase = 240;
      const baseWidth = Math.max(120, (contentWidth || fallbackBase) - contentPaddingX - metrics.paddingX);
      return {
        font: metrics.font,
        widths: {
          1: baseWidth,
          2: Math.max(90, baseWidth - nestedIndent),
          3: Math.max(70, baseWidth - nestedIndent * 2)
        }
      };
    }
    
    function truncateTitle(text, level, font, maxWidths) {
      const maxWidth = maxWidths[level] || maxWidths[3] || 180;
      if (getTextWidth(text, font) <= maxWidth) return text;
      
      let left = 0, right = text.length, best = '';
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const candidate = text.substring(0, mid);
        if (getTextWidth(candidate + '...', font) <= maxWidth) {
          best = candidate;
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      
      const searchStart = Math.max(0, best.length - 15);
      const searchText = text.substring(searchStart, best.length);
      const lastSpace = searchText.lastIndexOf(' ');
      const lastPunct = Math.max(searchText.lastIndexOf('.'), searchText.lastIndexOf(','), searchText.lastIndexOf(':'), searchText.lastIndexOf(';'));
      
      if (lastSpace > searchText.length * 0.5) {
        best = text.substring(0, searchStart + lastSpace);
      } else if (lastPunct > searchText.length * 0.5) {
        best = text.substring(0, searchStart + lastPunct);
      }
      
      return best.replace(/\s+$/, '').replace(/[\.,;:!?]+$/, '') + '...';
    }
    
    let html = '<ul class="toc-list">', currentLevel = 0, openLists = 0;
    const { font, widths: maxWidths } = getMaxWidths();
    
    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));
      const text = heading.textContent.trim();
      const truncatedText = truncateTitle(text, level, font, maxWidths);
      const id = heading.id || 'heading-' + index;
      
      if (!heading.id) heading.id = id;
      
      if (level > currentLevel) {
        while (currentLevel < level) {
          if (currentLevel > 0) {
            html += '<ul class="toc-list toc-nested">';
            openLists++;
          }
          currentLevel++;
        }
      } else if (level < currentLevel) {
        while (currentLevel > level) {
          html += '</ul>';
          openLists--;
          currentLevel--;
        }
      }
      
      html += `<li class="toc-item toc-level-${level}"><a href="#${id}" class="toc-link" data-level="${level}" title="${text}">${truncatedText}</a></li>`;
    });
    
    while (openLists > 0) {
      html += '</ul>';
      openLists--;
    }
    html += '</ul>';
    tocNav.innerHTML = html;
    
    tocLinks = Array.from(tocNav.querySelectorAll('.toc-link'));
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const target = document.getElementById(this.getAttribute('href').substring(1));
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    const topButtons = document.querySelectorAll('.toc-top-btn');
    topButtons.forEach(btn => {
      if (!btn.dataset.listenerAttached) {
        btn.addEventListener('click', e => {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        btn.dataset.listenerAttached = 'true';
      }
    });
    
    initScrollSpy();
    updateActiveLink();
    updateTocFloatingTop();
  }
  
  tocToggle.addEventListener('click', () => {
    tocHeader.classList.toggle('expanded');
    tocContent.classList.toggle('expanded');
    const icon = tocToggle.querySelector('ion-icon');
    icon.setAttribute('name', tocContent.classList.contains('expanded') ? 'chevron-up-outline' : 'chevron-down-outline');
  });
  
  generateTOC();
  
  let resizeTimeout;
  let resizeRaf = null;
  window.addEventListener('resize', () => {
    if (resizeRaf) cancelAnimationFrame(resizeRaf);
    resizeRaf = requestAnimationFrame(() => {
      updateTocMinTop();
      updateTocFloatingTop();
    });
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      generateTOC();
      if (window.innerWidth >= 1024) {
        tocHeader.classList.remove('expanded');
        tocContent.classList.remove('expanded');
        tocToggle.querySelector('ion-icon').setAttribute('name', 'chevron-down-outline');
      }
    }, 250);
  });

  function handleMediaChange() {
    updateTocMinTop();
    updateTocFloatingTop();
  }

  if (fullWidthMedia.addEventListener) {
    fullWidthMedia.addEventListener('change', handleMediaChange);
    mobileMedia.addEventListener('change', handleMediaChange);
  } else if (fullWidthMedia.addListener) {
    fullWidthMedia.addListener(handleMediaChange);
    mobileMedia.addListener(handleMediaChange);
  }
});
</script>
